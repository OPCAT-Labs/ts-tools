/**

The file cat721Guard_12_12_2.js is generated by `npm run gen:guard`, do not modify this file

*/

import { ConstantsLib, INVALID_INDEX, NFT_GUARD_COLLECTION_TYPE_MAX_2, NFT_GUARD_COLLECTION_TYPE_MAX, OUTPUT_LOCKING_SCRIPT_HASH_LEN, TX_INPUT_COUNT_MAX_12, TX_OUTPUT_COUNT_MAX_12 } from "../constants.js";
import { CAT721GuardStateLib } from "./cat721GuardStateLib.js";
import { CAT721StateLib } from "./cat721StateLib.js";
import { CAT721GuardConstState, CAT721State } from "./types.js";
import { ByteString, ContextUtils, FixedArray, SmartContract, StdUtils, TxUtils, assert, byteStringToInt, fill, hash160, intToByteString, len, method, slice, tags, toByteString, Sig, PubKey } from "@opcat-labs/scrypt-ts-opcat";
import { CatTags } from "../catTags.js";
import { OwnerUtils } from "../utils/ownerUtils.js";
/**
 * The CAT721 guard contract
 * @category Contract
 * @category CAT721
 * @onchain
 */
@tags([CatTags.CAT721_GUARD_TAG, CatTags.CAT721_GUARD_12_12_2_TAG])
export class CAT721Guard_12_12_2 extends SmartContract<CAT721GuardConstState> {
    @method()
    public unlock(
        // deployer signature to prevent guard hijack
        deployerSig: Sig,
        deployerPubKey: PubKey,
        nextStateHashes: FixedArray<ByteString, typeof TX_OUTPUT_COUNT_MAX_12>,
        // the logic is the same as cat20 guard
        ownerAddrOrScriptHashes: FixedArray<ByteString, typeof TX_OUTPUT_COUNT_MAX_12>,
        // localId list of curTx nft outputs
        // note that the element index of this array does NOT correspond to the outputIndex of curTx nft output
        // and the order of nft outputs MUST be the same as the order of nft inputs excluding the burned ones
        // e.g.
        // this.state.nftScripts        ['nftA', 'nftB', 'fd', 'fc']
        // this.state.nftScriptIndexes  [0, 0, 1, -1, -1, -1]
        // -> input nfts in curTx     [nftA_20, nftA_21, nftB_10, /, /, /]
        // this.state.burnMasks         [false, true, false, false, false, false]
        // output nftScriptIndexes    [-1, 0, 1, -1, -1]
        // -> output nfts in curTx    [/, nftA_20, nftB_10, /, /]
        // -> outputLocalIds
        //        correct             [20, 10, -1, -1, -1]
        //        invalid             [-1, 20, 10, -1, -1]
        outputLocalIds: FixedArray<bigint, typeof TX_OUTPUT_COUNT_MAX_12>,
        nftScriptHashIndexes: FixedArray<bigint, typeof TX_OUTPUT_COUNT_MAX_12>,
        outputSatoshis: FixedArray<bigint, typeof TX_OUTPUT_COUNT_MAX_12>,
        cat721States: FixedArray<CAT721State, typeof TX_INPUT_COUNT_MAX_12>,
        // the number of curTx outputs except for the state hash root output
        outputCount: bigint
    ) {
        // F14 Fix: Verify deployer signature to prevent guard hijack
        OwnerUtils.checkUserOwner(deployerPubKey, this.state.deployerAddr)
        assert(this.checkSig(deployerSig, deployerPubKey), 'deployer signature is invalid')

        CAT721GuardStateLib.formalCheckState(this.state, 12);

        // how many different types of nfts in curTx inputs
        let inputNftTypes = 0n;
        const nftScriptPlaceholders: FixedArray<ByteString, typeof NFT_GUARD_COLLECTION_TYPE_MAX> = [
            ConstantsLib.TOKEN_SCRIPT_HASH_PLACEHOLDER_FF,
            ConstantsLib.TOKEN_SCRIPT_HASH_PLACEHOLDER_FE,
            ConstantsLib.TOKEN_SCRIPT_HASH_PLACEHOLDER_FD,
            ConstantsLib.TOKEN_SCRIPT_HASH_PLACEHOLDER_FC,
        ];
        for (let i = 0; i < NFT_GUARD_COLLECTION_TYPE_MAX; i++) {
            if (i >= NFT_GUARD_COLLECTION_TYPE_MAX_2) {
                assert(this.state.nftScriptHashes[Number(i)] == nftScriptPlaceholders[Number(i)], 'nft script hash is invalid, should be placeholder');
            }
        }
        for (let i = 0; i < NFT_GUARD_COLLECTION_TYPE_MAX_2; i++) {
            if (this.state.nftScriptHashes[i] != nftScriptPlaceholders[i]) {
                inputNftTypes++;
            }
        }
        
        // ensure there are no placeholders between valid nft scripts in curState.nftScriptHashes
        for (let i = 0; i < NFT_GUARD_COLLECTION_TYPE_MAX_2; i++) {
            if (i < Number(inputNftTypes)) {
                assert(this.state.nftScriptHashes[i] != nftScriptPlaceholders[i], 'nft script hash is invalid, should not be placeholder')
                assert(len(this.state.nftScriptHashes[i]) == OUTPUT_LOCKING_SCRIPT_HASH_LEN, 'nft script hash length is invalid')
            } else {
                assert(this.state.nftScriptHashes[i] == nftScriptPlaceholders[i], 'nft script hash is invalid, should be placeholder')
            }
        }
        assert(inputNftTypes > 0n, 'input nft types should be greater than 0');

        // go through input nfts;
        let nftScriptIndexMax = INVALID_INDEX;
        // nextNfts are all the input nfts except the burned ones
        const nextNfts: FixedArray<ByteString, typeof TX_OUTPUT_COUNT_MAX_12> = fill(toByteString(''), TX_OUTPUT_COUNT_MAX_12);
        let nextNftCount = 0n;
        const inputCount = this.ctx.inputCount;
        // F11 Fix: Ensure input count doesn't exceed variant's maximum
        assert(inputCount <= TX_INPUT_COUNT_MAX_12, 'input count exceeds variant maximum')
        for (let i = 0n; i < TX_INPUT_COUNT_MAX_12; i++) {
            const nftScriptIndex = byteStringToInt(slice(this.state.nftScriptIndexes, i, i + 1n));
            const burnMask = slice(this.state.nftBurnMasks, i, i + 1n) == toByteString('01') ? true : false;
            if (i < inputCount) {
                // F-07 Fix: Add lower bound check for script index
                assert(nftScriptIndex >= INVALID_INDEX, 'nft script index out of range');
                assert(nftScriptIndex < inputNftTypes);
                if (nftScriptIndex != INVALID_INDEX) {
                    // this is a nft input
                    const nftScriptHash = this.state.nftScriptHashes[Number(nftScriptIndex)];
                    assert(nftScriptHash == ContextUtils.getSpentScriptHash(this.ctx.spentScriptHashes, BigInt(i)), 'nft script hash is invalid');
                    CAT721StateLib.checkState(cat721States[Number(i)]);
                    assert(ContextUtils.getSpentDataHash(this.ctx.spentDataHashes, BigInt(i)) == CAT721StateLib.stateHash(cat721States[Number(i)]), 'nft state hash is invalid');
                    nftScriptIndexMax = nftScriptIndex > nftScriptIndexMax ? nftScriptIndex : nftScriptIndexMax;
                    if (!burnMask) {
                        // this nft is not burned
                        nextNfts[Number(nextNftCount)] = nftScriptHash + hash160(intToByteString(cat721States[Number(i)].localId))
                        nextNftCount++;
                    }
                } else {
                    // this is a non-nft input
                    assert(!burnMask, 'nft burn mask is invalid');
                }
            } else {
                assert(nftScriptIndex == INVALID_INDEX, 'nft script index is invalid');
            }
        }
        assert(nftScriptIndexMax >= 0n && nftScriptIndexMax == inputNftTypes - 1n, 'nft script index max is invalid');

        // build curTx outputs
        assert(outputCount >= 0n && outputCount <= TX_OUTPUT_COUNT_MAX_12, 'output count is invalid');
        let outputNftCount = 0n;
        let outputs = toByteString('');
        for (let i = 0n; i < TX_OUTPUT_COUNT_MAX_12; i++) {
            if (i < outputCount) {
                const ownerAddrOrScriptHash = ownerAddrOrScriptHashes[Number(i)];
                const nftScriptIndex = nftScriptHashIndexes[Number(i)];
                // F-07 Fix: Add lower bound check for script index
                assert(nftScriptIndex >= INVALID_INDEX, 'nft script index out of range');
                assert(nftScriptIndex < inputNftTypes, 'nft script index is invalid');
                if (nftScriptIndex != INVALID_INDEX) {
                    // this is an nft output
                    // C.4 Fix: Validate owner address encoding
                    OwnerUtils.checkOwnerAddr(ownerAddrOrScriptHash)
                    // F-03 Fix: Ensure output satoshis is positive
                    assert(outputSatoshis[Number(i)] > 0n, 'output satoshis must be positive');
                    const nftScriptHash = this.state.nftScriptHashes[Number(nftScriptIndex)];
                    const localId = outputLocalIds[Number(outputNftCount)];
                    assert(localId >= 0n, 'local id is invalid');
                    assert(nextNfts[Number(outputNftCount)] == nftScriptHash + hash160(intToByteString(localId)), 'next nft is invalid');
                    outputNftCount = outputNftCount + 1n;
                    const nftStateHash = CAT721StateLib.stateHash({
                        ownerAddr: ownerAddrOrScriptHash,
                        localId: localId,
                    });
                    assert(nextStateHashes[Number(i)] == nftStateHash, 'next state hash is invalid');
                    outputs += TxUtils.buildDataOutput(
                        this.state.nftScriptHashes[Number(nftScriptIndex)],
                        outputSatoshis[Number(i)],
                        nftStateHash
                    )
                } else {
                    // this is a non-nft output
                    // locking script of this non-nft output cannot be the same as any nft script in curState
                    for (let j = 0; j < NFT_GUARD_COLLECTION_TYPE_MAX_2; j++) {
                        assert(ownerAddrOrScriptHash != this.state.nftScriptHashes[j], 'owner addr or script hash is invalid');
                    }
                    outputs += TxUtils.buildDataOutput(
                        ownerAddrOrScriptHash,
                        outputSatoshis[Number(i)],
                        nextStateHashes[Number(i)]
                    )
                }
            } else {
                assert(len(ownerAddrOrScriptHashes[Number(i)]) == 0n, 'owner addr or script hash is invalid, should be 0');
                assert(nftScriptHashIndexes[Number(i)] == INVALID_INDEX)
                assert(outputLocalIds[Number(i)] == INVALID_INDEX, 'output local id is invalid, should be -1');
                assert(nextStateHashes[Number(i)] == toByteString(''), 'next state hash is invalid, should be empty');
                assert(outputSatoshis[Number(i)] == 0n, 'output satoshis is invalid, should be 0');
            }
        }
        // ensure outputLocalIds is default value when there are no more output nfts
        for (let i = 0; i < TX_OUTPUT_COUNT_MAX_12; i++) {
            if (i >= outputNftCount) {
                assert(outputLocalIds[Number(i)] == INVALID_INDEX, 'output local id is invalid, should be -1');
            }
        }

        // check nft consistency of inputs and outputs
        assert(nextNftCount == outputNftCount, 'next nft count is invalid');

        // confine curTx outputs
        assert(this.checkOutputs(outputs), 'Outputs mismatch with the transaction context');
    }
}