import fs from 'fs';
import { arrayIncludes } from './utils';

export type ImportExpression = {
  expression: string;
  importPath: string;
  index: number;
};

export type Symbol = {
  value: string;
  index: number;
};

export type ExportSymbol = Symbol & {
  type: 'struct' | 'library' | 'contract';
};

export const buildinSymbols = [
  // basic types
  'bytes',
  'int',
  'bool',

  // struct
  'struct',

  'Tx',
  'SigHash',

  // type infer
  'auto',

  // domain subtypes
  'PubKey',
  'Sig',
  'Ripemd160',
  'Sha1',
  'Sha256',
  'SigHashType',
  'SigHashPreimage',
  'OpCodeType',
  'OpCode',

  // subtype of int
  'PrivKey',

  'const',

  'if',
  'else',
  'loop',

  'exit',
  'require',
  'return',

  // Code Separator

  // keyword
  'static',
  'public',
  'private',

  'library',
  'contract',

  'function',
  'constructor',

  // decorator
  'prop',
  'method',

  // inline assembly
  'asm',

  // Library Functions
  'abs',
  'min',
  'max',
  'within',

  'ripemd160',
  'sha1',
  'sha256',
  'hash160',
  'hash256',
  'flattenSha256',

  'checkSig',
  'checkMultiSig',

  'pack',
  'unpack',

  'reverseBytes',
];

export class ScryptFileParser {
  static parseScryptFile(fileContent: string) {
    // for .scrypt file reference, check the link https://scryptdoc.readthedocs.io/en/latest/

    // we parse each line of the .scrypt file;
    // and get the import expressions, export symbols, symbols that not defined in the current .scrypt file;
    // note: because the template is generated by the transpiler, so here we suppose the template do not have any comment expressions;

    const importExpressions = this.parseImportExpression(fileContent);
    const exportSymbols = this.parseExportSymbols(fileContent);
    const usedSymbols = this.parseUsedSymbols(fileContent, exportSymbols);

    return {
      importExpressions,
      exportSymbols,
      usedSymbols,
    };
  }

  static parseUsedSymbols(fileContent: string, exportSymbols: ExportSymbol[]) {
    // suppose the symbols are not wrapped by asm {}
    // suppose the symbols are not wrapped by ""

    // match function functionName(ArgTyep1 arg1, ArgType2 arg2): ReturnType {
    const functionRegex = /\bfunction\s*.+\{/g;
    const constructorRegex = /\bconstructor\s*.+\{/g;

    // match propType propVariable;
    // also match return variable;
    // eslint-disable-next-line no-useless-escape
    const propsRegex = /\s+([\w\[\]]+)\s(\w+);/g;

    // match type variable =
    // also match static const type variable
    // eslint-disable-next-line no-useless-escape
    const localVariableRegex = /\s+([\w\[\]]+)\s(\w+)\s=/g;

    // match xxx.yyy, xxx.yyy()
    // also match this.xxx, should be excluded
    // do not match xxx.yyy.zzz
    const accessVariableRegex = /(\w+)\.\w+(?:\(\))?/g;

    // match new xxx
    const newRegex = /\bnew\s+(\w+)\s*\(/g;

    const localVariables: Symbol[] = [];
    const propVariables: Symbol[] = [];
    const argumentVariables: Symbol[] = [];
    const types: Symbol[] = [];
    const accessVariables: Symbol[] = [];

    const stripArray = (type: string) => {
      const idx = type.indexOf('[');
      if (idx === -1) {
        return type;
      }
      return type.slice(0, idx);
    };

    // parse function declaration
    {
      let match: RegExpExecArray | null;
      while ((match = functionRegex.exec(fileContent) || constructorRegex.exec(fileContent))) {
        const lParenthesisIndex = match[0].indexOf('(');
        const rParenthesisIndex = match[0].indexOf(')');

        const argumentsString = match[0].slice(lParenthesisIndex + 1, rParenthesisIndex);
        if (argumentsString.trim() !== '') {
          const argsIndex = match.index + match[0].indexOf(argumentsString);
          let argIndex = argsIndex;
          const argumentList = argumentsString.split(',');
          for (const arg of argumentList) {
            const index = argIndex;
            const parts = arg.trim().split(' ');
            const type = stripArray(parts[0].trim());
            const value = parts[1].trim();

            types.push({
              value: type,
              index: index + arg.indexOf(type),
            });
            argumentVariables.push({
              value,
              index: index + arg.indexOf(value),
            });

            argIndex += arg.length + ','.length;
          }
        }

        const returnTypeString = match[0].slice(rParenthesisIndex + 1);
        const returnType = returnTypeString.match(/\w+/)?.[0]?.trim() || '';
        if (returnType) {
          const index = match.index + rParenthesisIndex + 1 + returnTypeString.indexOf(returnType);
          types.push({
            value: returnType,
            index,
          });
        }
      }
    }

    // parse contract property, struct property
    {
      let match: RegExpExecArray | null;
      while ((match = propsRegex.exec(fileContent))) {
        if (match[0].trim().startsWith('return ')) continue;
        const propType = stripArray(match[1]);
        const propVariable = match[2];
        propVariables.push({
          value: propVariable,
          index: match.index + match[0].indexOf(propVariable),
        });
        types.push({
          value: propType,
          index: match.index + match[0].indexOf(propType),
        });
      }
    }

    // parse local variable declaration
    {
      let match: RegExpExecArray | null;
      while ((match = localVariableRegex.exec(fileContent))) {
        const type = stripArray(match[1]);
        localVariables.push({
          value: match[2],
          index: match.index + match[0].indexOf(match[2]),
        });
        types.push({
          value: type,
          index: match.index + match[0].indexOf(type),
        });
      }
    }

    // parse variable access
    {
      let match: RegExpExecArray | null;
      while ((match = accessVariableRegex.exec(fileContent))) {
        // exclude this.xxx
        if (match[0].trim().startsWith('this.')) continue;
        // exclude xxx.scrypt
        if (match[0].trim().endsWith('.scrypt')) continue;
        // exclude yyy.zzz in xxx.yyy.zzz
        if (fileContent[match.index - 1] === '.') continue;

        accessVariables.push({
          value: match[1],
          index: match.index + match[0].indexOf(match[1]),
        });
      }
    }

    // parse new xxx
    {
      let match: RegExpExecArray | null;
      while ((match = newRegex.exec(fileContent))) {
        types.push({
          value: match[1],
          index: match.index + match[0].indexOf(match[1]),
        });
      }
    }

    const usedImportedSymbols: Symbol[] = [];
    const usedExportedSymbols: Symbol[] = [];

    // for access variables, we need to check if the access variable is defined in the current .scrypt file
    for (const accessVariable of accessVariables) {
      // is accessing a local variable
      if (arrayIncludes(localVariables, accessVariable, (a, b) => a.value === b.value)) {
        continue;
      }
      // is accessing a argument variable
      if (arrayIncludes(argumentVariables, accessVariable, (a, b) => a.value === b.value)) {
        continue;
      }
      // is accessing a built-in type
      if (arrayIncludes(buildinSymbols, accessVariable, (a, b) => a === b.value)) {
        continue;
      }
      // is accessing a exportSymbols
      if (arrayIncludes(exportSymbols, accessVariable, (a, b) => a.value === b.value)) {
        usedExportedSymbols.push(accessVariable);
        continue;
      }

      // not found in the current .scrypt file, so it is an outer symbol
      usedImportedSymbols.push(accessVariable);
    }

    // for types, we need to check if the type is defined in the current .scrypt file, or is a built-in type
    for (const type of types) {
      // is accessing a built-in type
      if (buildinSymbols.includes(type.value)) {
        continue;
      }

      // is accessing a export symbol
      if (arrayIncludes(exportSymbols, type, (a, b) => a.value === b.value)) {
        usedExportedSymbols.push(type);
        continue;
      }

      // not found in the current .scrypt file, so it is an outer symbol
      usedImportedSymbols.push(type);
    }

    return {
      exportedSymbols: usedExportedSymbols,
      importedSymbols: usedImportedSymbols,
    };
  }

  static parseImportExpression(fileContent: string): ImportExpression[] {
    // we parse the import expression from the line;
    // and get the import path;
    /*
      import "../types.scrypt";
      import "./cat721State.scrypt";
      import "./cat721GuardState.scrypt";
      import "../utils/ownerUtils.scrypt";
      import "@opcat-labs/scrypt-ts-transpiler-opcat/assets/smart-contract/types/structs.scrypt";
      import "@opcat-labs/scrypt-ts-transpiler-opcat/assets/smart-contract/builtin-libs/txUtils.scrypt";
    */
    const regex = /\bimport\s+['"]([^'"]+)['"];/g;
    let match: RegExpExecArray | null;
    const importExpressions: ImportExpression[] = [];
    while ((match = regex.exec(fileContent))) {
      importExpressions.push({
        expression: match[0],
        importPath: match[1],
        index: match.index,
      });
    }
    return importExpressions;
  }

  static parseExportSymbols(fileContent: string): ExportSymbol[] {
    // we parse the export symbols from the line;
    // for getting the export symbols, we need to parse the line that starts with contract, struct, library;

    /*
    contract symbol:
    contract CAT721 {
    ...
    }

    struct symbol:
    struct Cat721State {
    ...
    }

    library symbol:
    library Cat721Guard {
    ...
    }
    
    
    */

    const contractRegex = /\bcontract\s+([\w]+)\s+{/g;
    const structRegex = /\bstruct\s+([\w]+)\s+{/g;
    const libraryRegex = /\blibrary\s+([\w]+)\s+{/g;

    let match: RegExpExecArray | null;
    const exportSymbols: ExportSymbol[] = [];
    while ((match = contractRegex.exec(fileContent))) {
      exportSymbols.push({
        type: 'contract',
        value: match[1],
        index: match.index + match[0].indexOf(match[1]),
      });
    }
    while ((match = structRegex.exec(fileContent))) {
      exportSymbols.push({
        type: 'struct',
        value: match[1],
        index: match.index + match[0].indexOf(match[1]),
      });
    }
    while ((match = libraryRegex.exec(fileContent))) {
      exportSymbols.push({
        type: 'library',
        value: match[1],
        index: match.index + match[0].indexOf(match[1]),
      });
    }
    return exportSymbols;
  }

  static verifyParseResult(filePath: string) {
    console.log(`verifyParse ${filePath}`);
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const parsedResult = ScryptFileParser.parseScryptFile(fileContent);
    const { importExpressions, exportSymbols, usedSymbols } = parsedResult;

    // check importExpressions
    for (const importExpression of importExpressions) {
      const expression = importExpression.expression;
      const actualExpression = fileContent.slice(
        importExpression.index,
        importExpression.index + expression.length,
      );
      if (actualExpression !== expression) {
        throw new Error(`Import expression ${expression} is not equal to ${actualExpression}`);
      }
    }

    // check exportSymbols
    for (const exportSymbol of exportSymbols) {
      const value = exportSymbol.value;
      const actualValue = fileContent.slice(exportSymbol.index, exportSymbol.index + value.length);
      if (actualValue !== value) {
        throw new Error(`Export symbol ${value} is not equal to ${actualValue}`);
      }
    }

    // check importedSymbols
    for (const importedSymbol of usedSymbols.importedSymbols) {
      const value = importedSymbol.value;
      const actualValue = fileContent.slice(
        importedSymbol.index,
        importedSymbol.index + value.length,
      );
      if (actualValue !== value) {
        throw new Error(`used Imported symbol ${value} is not equal to ${actualValue}`);
      }
    }

    // check exportedSymbols
    for (const exportedSymbol of usedSymbols.exportedSymbols) {
      const value = exportedSymbol.value;
      const actualValue = fileContent.slice(
        exportedSymbol.index,
        exportedSymbol.index + value.length,
      );
      if (actualValue !== value) {
        throw new Error(`used Exported symbol ${value} is not equal to ${actualValue}`);
      }
    }
  }
}
