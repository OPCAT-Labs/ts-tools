/* eslint-disable no-useless-escape */
import fs from 'node:fs';
import path from 'node:path';
import { parseConfigFileTextToJson } from 'typescript';
import { glob } from 'glob';
import { expectTranspilerErrors } from './invalidTranspilerErrors';

type ContractMetadata = {
  hasContract: boolean;
  hasLibrary: boolean;
  contractName: string;
  libraryNames: string[];
  stateType: string;
  fileName: string;
  filePath: string;
};

// console.log('import.meta.dirname: ', import.meta, process.cwd(), __dirname)
const testDir = path.join(__dirname, '..');

main();

function main() {
  const tsConfigPath = path.join(testDir, 'tsconfig.json');
  const tsConfig = parseConfigFileTextToJson(tsConfigPath, fs.readFileSync(tsConfigPath, 'utf8'));

  const includeFiles = tsConfig.config.include
    .map((reg) => glob.sync(reg, { cwd: testDir }))
    .flat();
  const excludeFiles = tsConfig.config.exclude
    .map((reg) => glob.sync(reg, { cwd: testDir }))
    .flat();
  const files = includeFiles
    .filter((file) => !excludeFiles.includes(file))
    .sort((file1, file2) => file1.localeCompare(file2));

  const validFiles = files.filter((file) => !covertToPosix(file).includes('/invalid/'));
  const invalidFiles = files.filter((file) => covertToPosix(file).includes('/invalid/'));

  const contractList = validFiles.map(getContractMetadata);
  generateValidTranspileSpec(contractList);
  generateCompileSpec(contractList);
  generateInvalidTranspileSpec(invalidFiles.map(getContractMetadata));
}

function generateValidTranspileSpec(list: ContractMetadata[]) {
  const geneFiles = list.filter((v) => v.hasContract || v.hasLibrary);
  const notGeneFiles = list.filter((v) => !v.hasContract && !v.hasLibrary);

  const importsContent = geneFiles
    .map((v) => {
      const relativePath = path.relative(path.resolve(testDir, '.'), v.filePath);
      const contractImport = v.hasContract
        ? `import { ${v.contractName} } from '${covertToPosix(relativePath)}';`
        : '';

      const libraryImports = v.libraryNames
        .map((name) => `import { ${name} } from '${covertToPosix(relativePath)}';`)
        .join('\n');
      const libraryImport = v.hasLibrary ? libraryImports : '';
      if (v.hasContract && v.hasLibrary) {
        return `${contractImport}\n${libraryImport}`;
      } else {
        return contractImport || libraryImport;
      }
    })
    .join('\n');

  const testCasesContent = geneFiles
    .map((v) => {
      const filePath = '`' + covertToPosix(v.filePath) + '`';

      const contractExpect = v.hasContract
        ? `    expect(loadTransformerResult(${v.contractName}).success).be.true;`
        : '';
      const libraryExpects = v.libraryNames
        .map((name) => `    expect(loadTransformerResult(${name}).success).be.true;`)
        .join('\n');
      const libraryExpect = v.hasLibrary ? libraryExpects : '';
      let expectContent = '';

      if (v.hasContract && v.hasLibrary) {
        expectContent = `${contractExpect}\n${libraryExpect}`;
      } else {
        expectContent = contractExpect || libraryExpect;
      }

      return `  it(' should transpile ${filePath} successfully', async () => {
${expectContent}
  })`;
    })
    .join('\n\n');

  const content = `
/**
 * This file is generated by \`yarn gen:spec\`, do not edit it manually
 */

import chai, { expect } from 'chai';
import chaiExclude from 'chai-exclude';
import { loadTransformerResult } from '../utils/helper';

chai.use(chaiExclude);

${importsContent}

describe('Test SmartContract transpiling', () => {
${testCasesContent}
})
`;
  console.log('generate transpile spec success');
  // console.log(
  //   'generated contracts: ',
  //   geneFiles.map((v) => v.filePath),
  // );
  console.log(
    'not generated contracts because of no contract class or library class in the file: ',
    notGeneFiles.map((v) => v.filePath),
  );

  fs.writeFileSync(path.join(testDir, 'specs', 'valid_transpile.spec.ts'), content);
}

function generateCompileSpec(list: ContractMetadata[]) {
  const geneFiles = list.filter((v) => v.hasContract);
  const notGeneFiles = list.filter((v) => !v.hasContract);

  const importsContents = geneFiles.map((v) => {
    const relativePath = path.relative(path.resolve(testDir, '.'), v.filePath);
    return `import { ${v.contractName} } from '${covertToPosix(relativePath)}';`;
  });
  const testCasesContents = geneFiles.map((v) => {
    const filePath = '`' + covertToPosix(v.filePath) + '`';
    if (!v.stateType) {
      return `  it(' should compile ${filePath} successfully', () => {
    expect(loadArtifact(${v.contractName})).not.be.null;
  })`;
    } else {
      return `  it(' should compile ${filePath} successfully', () => {
    const result = loadArtifact(${v.contractName});
    expect(result).not.be.null;
    expect(Relinker.getUnRenamedSymbol(result!.stateType!)).to.be.equal('${v.stateType}');
  })`;
    }
  });

  writeToChunkFiles();

  console.log('generate compile spec success');
  // console.log(
  //   'generated contracts: ',
  //   geneFiles.map((v) => v.filePath),
  // );
  console.log(
    'not generated contracts because of no contract class in the file: ',
    notGeneFiles.map((v) => v.filePath),
  );

  function writeToChunkFiles() {
    // split into chunks to parallel test
    const length = importsContents.length;
    const chunkSize = 5;
    for (let i = 0; i < length; i += chunkSize) {
      const importsContent = importsContents.slice(i, i + chunkSize).join('\n');
      const testCasesContent = testCasesContents.slice(i, i + chunkSize).join('\n\n');
      const index = i / 5;
      const content = `

/**
 * This file is generated by \`yarn gen:spec\`, do not edit it manually
 */

import chai, { expect } from 'chai';
import chaiExclude from 'chai-exclude';
import { Relinker } from '@scrypt-inc/scrypt-ts-transpiler-btc/dist/relinker';

chai.use(chaiExclude);

import { loadArtifact } from '../utils/helper.js';

${importsContent}

describe('Test SmartContract compiling: chunk-${index}', () => {
${testCasesContent}
})
`;
      const fileName = `compile-chunk${index}.spec.ts`;
      fs.writeFileSync(path.join(testDir, 'specs', fileName), content);
    }
  }

  // fs.writeFileSync(path.join(testDir, 'specs', 'compile.spec.ts'), content);
}

function generateInvalidTranspileSpec(list: ContractMetadata[]) {
  // only generate the files that have expect errors
  const expectErrorFiles = Object.keys(expectTranspilerErrors);
  const geneFiles = expectErrorFiles
    .map((fileName) => list.find((v) => path.basename(v.filePath).replace('.ts', '') === fileName))
    .filter((v) => v !== undefined)
    .filter((v) => v.hasContract || v.hasLibrary);
  // const geneFiles = list
  //   .filter((v) => v.hasContract || v.hasLibrary)
  //   .filter((v) => {
  //     const fileName = path.basename(v.filePath).replace('.ts', '');
  //     return expectErrorFiles.includes(fileName);
  //   })
  // ensure the file has contract or library
  geneFiles.forEach((v) => {
    if (!v.hasContract && !v.hasLibrary) {
      throw new Error(
        `contract or library ${v.filePath} is not found in \'contracts/invalid/${v.fileName}\'`,
      );
    }
  });

  const unUsedExpectErrorFiles = expectErrorFiles.filter(
    (fileName) => !geneFiles.some((v) => path.basename(v.filePath).replace('.ts', '') === fileName),
  );
  if (unUsedExpectErrorFiles.length > 0) {
    console.warn(
      `These files are not found in \'contracts/invalid\' folder, but are expected to have errors in invalidTranspilerErrors.ts: \n${unUsedExpectErrorFiles.map((v) => v + '.ts').join('\n')}\n\n`,
    );
    // throw new Error(
    //   `These files are not found in \'contracts/invalid\' folder, but are expected to have errors in invalidTranspilerErrors.ts: \n${unUsedExpectErrorFiles.map((v) => v + '.ts').join('\n')}\n\n`,
    // );
  }
  const notGeneFiles = list.filter((v) => !geneFiles.includes(v));

  const importsContent = geneFiles
    .map((v) => {
      const relativePath = path.relative(path.resolve(testDir, '.'), v.filePath);
      return `import { ${v.contractName || v.libraryNames[0]} } from '${covertToPosix(relativePath)}';`;
    })
    .join('\n');

  const testCasesContent = geneFiles
    .map((v) => {
      const fileName = path.basename(v.filePath).replace('.ts', '');
      const expectError = expectTranspilerErrors[fileName];
      return `  it('${expectError.testTitle}', async () => {
    const errors = loadTransformerResult(${v.contractName || v.libraryNames[0]}).errors;
    expect(errors).not.be.undefined;
    expect(errors)
      .excludingEvery(['srcRange'])
      .deep.eq(${leftPadSpace(JSON.stringify(expectError.errors, null, 2), 4)});
  })`;
    })
    .join('\n\n');

  const content = `

/**
 * This file is generated by \`yarn gen:spec\`, do not edit it manually
 */

import chai, { expect } from 'chai';
import chaiExclude from 'chai-exclude';
import { loadTransformerResult } from '../utils/helper';

${importsContent}

chai.use(chaiExclude);

describe('Test invalid SmartContract transpiling', () => {
${testCasesContent}
})
`;
  console.log('generate invalid transpile spec success');
  // console.log(
  //   'generated contracts: ',
  //   geneFiles.map((v) => v.filePath),
  // );
  console.log(
    'not generated contracts because of no expect errors in invalidTranspilerErrors.ts: ',
    notGeneFiles.map((v) => v.filePath),
  );

  fs.writeFileSync(path.join(testDir, 'specs', 'invalid_transpile.spec.ts'), content);
}

function getContractMetadata(filePath: string): ContractMetadata {
  const content = fs.readFileSync(path.resolve(testDir, filePath), 'utf8');

  const fileName = path.basename(filePath).replace('.ts', '');
  let hasContract = false;
  let contractName = '';
  const libraryNames: string[] = [];
  let stateType = '';
  let hasLibrary = false;

  const contractReg = /export +?class +?(\w+) extends +?SmartContract(<(\w+)>)? +?/g;
  const contractRes = contractReg.exec(content);
  if (contractRes) {
    hasContract = true;
    contractName = contractRes[1];
    stateType = contractRes[3] || '';
  }

  const libReg = /export +?class +?(\w+) extends +?SmartContractLib/g;
  let libRes = libReg.exec(content);
  while (libRes) {
    libraryNames.push(libRes[1]);
    hasLibrary = true;
    libRes = libReg.exec(content);
  }

  if (hasContract || hasLibrary) {
    return { hasContract, contractName, libraryNames, stateType, fileName, filePath, hasLibrary };
  } else {
    // heritage contracts;
    const heritageReg = /export +?class +?(\w+) extends +?(\w+)/g;
    const heritageRes = heritageReg.exec(content);

    // todo: better way to match heritage contracts
    if (heritageRes) {
      return {
        hasContract: true,
        contractName: heritageRes[1],
        libraryNames: [],
        stateType: '',
        fileName,
        filePath,
        hasLibrary: false,
      };
    } else {
      return {
        hasContract: false,
        contractName: '',
        libraryNames: [],
        stateType: '',
        fileName,
        filePath,
        hasLibrary: false,
      };
    }
  }
}

function covertToPosix(filePath: string) {
  return filePath.replaceAll(path.sep, path.posix.sep);
}

function leftPadSpace(multiLineStr: string, spaceCount: number) {
  return multiLineStr
    .split('\n')
    .map((line) => ' '.repeat(spaceCount) + line)
    .join('\n');
}
