import { getUnRenamedSymbol } from '../smart-contract/abiutils.js';
import { SmartContract } from '../smart-contract/smartContract.js';
import { SmartContractLib } from '../smart-contract/smartContractLib.js';
import md5 from 'md5';

/**
 * @ignore
 * The scrypt.index.json file generated by @opcat-labs/cli-opcat
 */
export type ScryptIndexJson = {
  scryptBase: string;
  bindings: {
    /**
     * The symbol of the binding, contract name or library name
     */
    symbol: string;

    /**
     * The path of the .scrypt file
     */
    path: string;

    /**
     * The md5 of lockingScript
     * exist when the file is a contract
     */
    md5?: string;

    /**
     * The state type of the contract
     * exist when the file is a stateful contract
     */
    stateType?: string;
  }[];
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type ContractOrLib = new (...args: any[]) => SmartContract<any> | SmartContractLib;

/** @ignore */
export function calcArtifactHexMD5(artifactHex: string): string {
  const chex = artifactHex.replace(/<([^>]+)>/g, '<>');
  return md5(chex);
}

/**
 * Check the integrity of the contracts:
 *
 * When compiling the contract, @opcat-labs/cli-opcat will generate the scrypt.index.json file, we will use this file to check the the artifact files are consistent with the scrypt.index.json file.
 * You should add the scrypt.index.json file to version control tools like git.
 *
 * @note: make sure you have call loadArtifacts() before calling this function.
 * @ignore
 * @param scryptIndexJson The scrypt.index.json file content generated by @opcat-labs/cli-opcat
 * @param contractClasses The contract classes to check
 */
export function checkIntegrity(scryptIndexJson: ScryptIndexJson, contractClasses: ContractOrLib[]) {
  const { bindings } = scryptIndexJson;
  for (const contract of contractClasses) {
    if (Object.prototype.isPrototypeOf.call(SmartContractLib, contract)) {
      // skip library, because library do not have lockingScript
      continue;
    }

    const artifact = (contract as typeof SmartContract).artifact;
    if (!artifact) {
      throw new Error(
        `${contract.name} has not loadArtifact, loadArtifact first before checkIntegrity`,
      );
    }
    const hexMd5 = calcArtifactHexMD5(artifact.hex);
    const indexMd5 = bindings.find(
      (b) => getUnRenamedSymbol(b.symbol) === getUnRenamedSymbol(artifact.contract),
    )?.md5;
    if (!indexMd5) {
      throw new Error(`${artifact.contract} md5 is not in the scrypt.index.json file`);
    }
    if (hexMd5 !== indexMd5) {
      throw new Error(
        `${artifact.contract} md5 '${hexMd5}' in artifact file is not consistent with '${indexMd5}' in the scrypt.index.json file`,
      );
    }
  }
}
