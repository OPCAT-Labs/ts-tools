/**
 * Off-chain signing utilities for preimage verification.
 *
 * This module provides functions to generate signatures off-chain using a
 * hardcoded private key. The signatures can then be verified on-chain using
 * checkDataSig, avoiding the need for on-chain signature generation which
 * bloats script size.
 *
 * @module sigUtils
 */

import { crypto, PrivateKey, PublicKey, Networks } from '@opcat-labs/opcat';
import { hash256, sha256 } from '../smart-contract/fns/hashes.js';
import { ByteString, Sig, SigHashPreimage } from '../smart-contract/types/primitives.js';
import { SHPreimage } from '../smart-contract/types/structs.js';
import { ContextUtils } from '../smart-contract/builtin-libs/contextUtils.js';
import { encodeSHPreimage } from './preimage.js';

const { ECDSA, Signature } = crypto;

/**
 * The internal private key derived from ContextUtils.privKey.
 * This ensures consistency between off-chain signing and on-chain verification.
 */
const INTERNAL_KEY = PrivateKey.fromHex(
  (ContextUtils.privKey as bigint).toString(16).padStart(64, '0'),
  Networks.defaultNetwork
);

/**
 * Signs a serialized preimage off-chain using the internal private key (from ContextUtils).
 *
 * This function generates a DER-encoded ECDSA signature that can be verified
 * on-chain using checkSig. The message is hashed with hash256 (double SHA256)
 * to match the transaction interpreter's sighash calculation.
 *
 * Note: For checkDataSig (which uses single SHA256), a different signature
 * would be needed. The JavaScript runtime uses this hash256 version for
 * compatibility with checkSig verification.
 *
 * @param preimage - The serialized preimage bytes to sign
 * @param sigHashType - The signature hash type (default: 0x01 for SIGHASH_ALL)
 * @returns A DER-encoded signature with sigHashType appended
 */
export function signPreimage(preimage: SigHashPreimage | ByteString, sigHashType: number = 0x01): Sig {
  // Compute hash256 of the preimage (double SHA256 for checkSig compatibility)
  // Reverse the hash to match checkSigImpl's verification format
  const hash = Buffer.from(hash256(preimage as ByteString), 'hex').reverse();

  // Sign the hash using ECDSA with internal key
  const signature = ECDSA.sign(hash, INTERNAL_KEY, 'little');

  // Get DER encoded signature
  const derSig = signature.toDER();

  // Append sigHashType byte
  const sigHashTypeByte = Buffer.from([sigHashType]);
  const fullSig = Buffer.concat([derSig, sigHashTypeByte]);

  return Sig(fullSig.toString('hex'));
}

/**
 * Signs a SHPreimage off-chain by first serializing it.
 *
 * This is a convenience wrapper around signPreimage that handles
 * the serialization of the SHPreimage struct.
 *
 * Note: Uses encodeSHPreimage (same as checkSigImpl) to ensure
 * the signature matches what checkSig expects.
 *
 * @param shPreimage - The SHPreimage struct to sign
 * @param sigHashType - The signature hash type (default: 0x01 for SIGHASH_ALL).
 *                      Should match shPreimage.sigHashType for verification to succeed.
 * @returns A DER-encoded signature with sigHashType appended
 */
export function signSHPreimage(shPreimage: SHPreimage, sigHashType: number = 0x01): Sig {
  // Serialize the SHPreimage using encodeSHPreimage (same as checkSigImpl uses)
  const preimage = encodeSHPreimage(shPreimage);
  return signPreimage(preimage, sigHashType);
}

/**
 * Signs arbitrary data off-chain using the internal key (ContextUtils.privKey).
 *
 * This function generates a pure DER-encoded ECDSA signature (NO sighash type)
 * that can be verified on-chain using checkDataSig. The message is hashed with
 * single SHA256 to match OP_CHECKSIGFROMSTACK behavior.
 *
 * Note: This uses the internal key from ContextUtils. For signing with
 * a custom private key (e.g., Oracle scenarios), use signData() instead.
 *
 * @param message - The message bytes to sign
 * @returns A pure DER-encoded signature (no sighash type appended)
 */
export function signDataWithInternalKey(message: ByteString): Sig {
  return signData(INTERNAL_KEY, message);
}

/**
 * Signs arbitrary data with a custom private key for use with checkDataSig (OP_CHECKSIGFROMSTACK).
 *
 * This function generates a pure DER-encoded ECDSA signature (NO sighash type)
 * that can be verified on-chain using checkDataSig. The message is hashed with
 * single SHA256 to match OP_CHECKSIGFROMSTACK behavior.
 *
 * Use this method for Oracle scenarios where you need to sign data with a specific
 * private key that the contract will verify against.
 *
 * @param privateKey - The private key to sign with
 * @param message - The message bytes to sign
 * @returns A pure DER-encoded signature (no sighash type appended)
 *
 * @example
 * ```typescript
 * // Oracle signs price data
 * const oraclePrivKey = PrivateKey.fromWIF('...');
 * const priceData = toByteString('BTC/USD:50000', true);
 * const sig = signData(oraclePrivKey, priceData);
 *
 * // Contract verifies using checkDataSig
 * // assert(this.checkDataSig(sig, priceData, oraclePubKey));
 * ```
 */
export function signData(privateKey: PrivateKey, message: ByteString): Sig {
  // Compute single SHA256 of the message for checkDataSig compatibility
  // Reverse the hash for little-endian format (same as OP_CHECKSIGFROMSTACK)
  const hash = Buffer.from(sha256(message), 'hex').reverse();

  // Sign the hash using ECDSA
  const signature = ECDSA.sign(hash, privateKey, 'little');

  // Get pure DER encoded signature (NO sighash type for OP_CHECKSIGFROMSTACK)
  const derSig = signature.toDER();

  return Sig(derSig.toString('hex'));
}

/**
 * Signs a SHPreimage off-chain for use with checkDataSig (OP_CHECKSIGFROMSTACK).
 *
 * This is a convenience wrapper that serializes the SHPreimage and signs it
 * using single SHA256 (matching checkDataSig behavior).
 *
 * @param shPreimage - The SHPreimage struct to sign
 * @returns A pure DER-encoded signature (no sighash type appended)
 */
export function signSHPreimageForCheckDataSig(shPreimage: SHPreimage): Sig {
  // Serialize the SHPreimage using encodeSHPreimage
  const preimage = encodeSHPreimage(shPreimage);
  return signDataWithInternalKey(preimage);
}

/**
 * Verifies a preimage signature off-chain.
 *
 * This function can be used to verify signatures before submitting
 * transactions, ensuring the signature is valid.
 *
 * @param sig - The signature to verify
 * @param preimage - The preimage that was signed
 * @returns true if the signature is valid, false otherwise
 */
export function verifyPreimageSig(sig: Sig, preimage: SigHashPreimage | ByteString): boolean {
  try {
    // Compute SHA256 hash of the preimage
    const hash = Buffer.from(sha256(preimage as ByteString), 'hex');

    // Get the signature bytes (without sigHashType)
    const sigBytes = Buffer.from(sig as string, 'hex');
    const derSig = sigBytes.slice(0, sigBytes.length - 1);

    // Parse the DER signature
    const signature = Signature.fromDER(derSig);

    // Get public key from ContextUtils
    const publicKey = PublicKey.fromHex(ContextUtils.pubKey as string);

    // Verify the signature
    return ECDSA.verify(hash, signature, publicKey, 'little');
  } catch (e) {
    return false;
  }
}
