import { Int32 } from '../types/primitives.js';
import { assert } from "./assert.js";
import { byteStringToInt, intToByteString } from './byteString.js';
import * as tools from 'uint8array-tools';


/**
 * Logical left shift matching on-chain OP_LSHIFT semantics.
 *
 * On-chain, OP_LSHIFT treats the stack item as raw bytes (sign-magnitude
 * encoding), interprets those bytes as an unsigned big-endian integer,
 * performs an unsigned logical left shift, and truncates the result back to
 * the original byte length.  This function replicates that behaviour so that
 * off-chain tests produce the same result as the deployed contract.
 *
 * Decision: the previous arithmetic-multiplication implementation diverged
 * from on-chain semantics for any negative or large value; replaced with a
 * byte-level unsigned shift + truncation to match OP_LSHIFT exactly.
 *
 * More detail about [Bitwise Operations]{@link https://docs.opcatlabs.io/how-to-write-a-contract/built-ins#bitwise-operator}
 * @category Bitwise Operations
 */
export function lshift(x: bigint, n: bigint): bigint {
  assert(n >= 0n, 'n < 0');
  const hex = intToByteString(x);
  if (hex.length === 0 || n === 0n) return x;
  const buf = tools.fromHex(hex);
  const origLen = buf.length;
  // Treat raw bytes as unsigned big-endian integer and shift left
  const unsigned = BigInt('0x' + tools.toHex(buf));
  const shifted = unsigned << n;
  // Truncate to original byte length: take last origLen bytes
  const shiftedHex = shifted.toString(16);
  const paddedHex = shiftedHex.length < origLen * 2
    ? shiftedHex.padStart(origLen * 2, '0')
    : shiftedHex;
  const truncatedHex = paddedHex.slice(-origLen * 2);
  return byteStringToInt(truncatedHex);
}

/**
 * Logical right shift matching on-chain OP_RSHIFT semantics.
 *
 * On-chain, OP_RSHIFT treats the stack item as raw bytes (sign-magnitude
 * encoding), interprets those bytes as an unsigned big-endian integer,
 * performs an unsigned logical right shift, and truncates the result back to
 * the original byte length.  This function replicates that behaviour so that
 * off-chain tests produce the same result as the deployed contract.
 *
 * Decision: the previous arithmetic-division implementation diverged from
 * on-chain semantics for any negative value; replaced with a byte-level
 * unsigned shift + truncation to match OP_RSHIFT exactly.
 *
 * Example: rshift(-6n, 2n)
 *   -6 in sign-magnitude = 0x86; unsigned = 134; 134 >>> 2 = 33 = 0x21
 *   result = byteStringToInt('21') = 33n  (not -1n as the old code returned)
 *
 * More detail about [Bitwise Operations]{@link https://docs.opcatlabs.io/how-to-write-a-contract/built-ins#bitwise-operator}
 * @category Bitwise Operations
 */
export function rshift(x: bigint, n: bigint): bigint {
  assert(n >= 0n, 'n < 0');
  const hex = intToByteString(x);
  if (hex.length === 0 || n === 0n) return x;
  const buf = tools.fromHex(hex);
  const origLen = buf.length;
  // Treat raw bytes as unsigned big-endian integer and shift right
  const unsigned = BigInt('0x' + tools.toHex(buf));
  const shifted = unsigned >> n;
  // Truncate to original byte length: take last origLen bytes
  const shiftedHex = shifted.toString(16).padStart(origLen * 2, '0');
  const truncatedHex = shiftedHex.slice(-origLen * 2);
  return byteStringToInt(truncatedHex);
}



/**
 * Inverts the bits of an Int value.
 * If the input value is 0n, it returns 0n directly.
 * @category Bitwise Operations
 * @onchain
 * @param a - The Int value to be inverted.
 * @returns {Int32} The inverted Int value.
 */

export function invert(a: Int32): Int32 {
  if (a === 0n) {
    return a;
  }

  const buffer = tools.fromHex(intToByteString(a));

  for (let i = 0; i < buffer.length; i++) {
    buffer[i] = ~buffer[i];
  }

  return byteStringToInt(tools.toHex(buffer));
}

/**
 * Performs a bitwise AND operation between two Int values.
 * @category Bitwise Operations
 * @onchain
 * @param a - First integer value
 * @param b - Second integer value
 * @returns Result of bitwise AND operation as Int
 */
export function and(a: Int32, b: Int32): Int32 {
  const size1 = intToByteString(a).length / 2;
  const size2 = intToByteString(b).length / 2;
  const maxSize = BigInt(Math.max(size1, size2));

  const ba = tools.fromHex(intToByteString(a, maxSize));
  const bb = tools.fromHex(intToByteString(b, maxSize));

  for (let i = 0; i < ba.length; i++) {
    ba[i] &= bb[i];
  }
  return byteStringToInt(tools.toHex(ba));
}




/**
 * Performs a bitwise OR operation on two Int values.
 * @category Bitwise Operations
 * @onchain
 * @param a - First integer value
 * @param b - Second integer value
 * @returns Result of bitwise OR operation as Int
 */
export function or(a: Int32, b: Int32): Int32 {
  const size1 = intToByteString(a).length / 2;
  const size2 = intToByteString(b).length / 2;
  const maxSize = BigInt(Math.max(size1, size2));

  const ba = tools.fromHex(intToByteString(a, maxSize));
  const bb = tools.fromHex(intToByteString(b, maxSize));

  for (let i = 0; i < ba.length; i++) {
    ba[i] |= bb[i];
  }

  return byteStringToInt(tools.toHex(ba));

}

/**
 * Performs a bitwise XOR operation on two Int values.
 * @category Bitwise Operations
 * @onchain
 * @param a First integer value
 * @param b Second integer value
 * @returns Result of the XOR operation as an Int
 */
export function xor(a: Int32, b: Int32): Int32 {
  const size1 = intToByteString(a).length / 2;
  const size2 = intToByteString(b).length / 2;
  const maxSize = BigInt(Math.max(size1, size2));

  const ba = tools.fromHex(intToByteString(a, maxSize));
  const bb = tools.fromHex(intToByteString(b, maxSize));

  for (let i = 0; i < ba.length; i++) {
    ba[i] ^= bb[i];
  }

  return byteStringToInt(tools.toHex(ba));
}