import { crypto, PublicKey, Interpreter } from '@opcat-labs/opcat';
import { Sig, PubKey, ByteString } from '../types/index.js';
import { sha256, toByteString } from '../fns/index.js';
import { AbstractContract } from '../abstractContract.js';

/**
 * Verifies a signature against an explicit message and public key.
 * Unlike checkSig which uses the transaction preimage as the implicit message,
 * checkDataSig allows verifying signatures on arbitrary data.
 *
 * @ignore
 * @param self - The contract instance (unused, kept for consistency with other check methods)
 * @param signature - The signature to verify in hex format (pure DER encoded, NO sighash type)
 * @param message - The message that was signed (will be SHA256 hashed once)
 * @param publickey - The public key in hex format to verify the signature against
 * @returns true if the signature is valid for the given message and public key,
 *          false if invalid or if encoding checks fail
 *
 * @remarks
 * - Uses SHA256 single hash on the message (not hash256 double hash)
 * - Stack order for OP_CHECKSIGFROMSTACK: <sig> <msg> <pubKey> (bottom to top)
 * - Unlike OP_CHECKSIG, OP_CHECKSIGFROMSTACK does NOT require sighash type appended to signature
 */
export function checkDataSigImpl(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  self: AbstractContract,
  signature: Sig,
  message: ByteString,
  publickey: PubKey
): boolean {
  const bufSig = Buffer.from(toByteString(signature), 'hex');
  const bufPubkey = Buffer.from(toByteString(publickey), 'hex');

  // Use Interpreter instance for encoding validation (reuse opcat library methods)
  const interpreter = new Interpreter();
  interpreter.flags = Interpreter.DEFAULT_FLAGS;

  if (
    !interpreter.checkDataSigSignatureEncoding(bufSig) ||
    !interpreter.checkPubkeyEncoding(bufPubkey)
  ) {
    return false;
  }

  let fSuccess = false;

  try {
    // For OP_CHECKSIGFROMSTACK, signature is pure DER (no sighash type)
    const sig = crypto.Signature.fromDER(bufSig);
    const pubkey = PublicKey.fromBuffer(bufPubkey, false);

    // Compute SHA256 of message (single hash, not double hash)
    // This matches the OP_CHECKSIGFROMSTACK behavior
    // Reverse to little-endian format (same as checkSigImpl) for signature verification
    const hashbuf = Buffer.from(sha256(message), 'hex').reverse();

    // Verify using ECDSA with little endian (same as OP_CHECKSIGFROMSTACK)
    fSuccess = crypto.ECDSA.verify(hashbuf, sig, pubkey, 'little');
  } catch (_err) {
    // invalid sig or pubkey
    fSuccess = false;
  }

  return fSuccess;
}
