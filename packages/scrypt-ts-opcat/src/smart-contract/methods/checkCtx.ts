import { AbstractContract } from '../abstractContract.js';
import { SHPreimage, Prevouts, SpentScriptHashes } from '../types/index.js';
import * as tools from 'uint8array-tools';
import { Outpoint, SpentAmounts, SpentDataHashes } from '../types/structs.js';
import { assert, hash256, intToByteString, slice } from '../fns/index.js';
import { InputIndex } from '../../globalTypes.js';

// ANYONECANPAY flag (0x80)
const SIGHASH_ANYONECANPAY = 0x80n;

// SIGHASH_NONE flag (0x02) - excludes outputs from signature
const SIGHASH_NONE = 0x02n;

// SIGHASH_SINGLE flag (0x03) - only signs the output at the same index
const SIGHASH_SINGLE = 0x03n;

// Mask to extract base sighash type (without ANYONECANPAY)
const SIGHASH_BASE_MASK = 0x1fn;

// Empty hash (32 zero bytes) used when ANYONECANPAY is set or for SIGHASH_NONE outputs
const EMPTY_HASH = '0000000000000000000000000000000000000000000000000000000000000000';

/**
 * Validates the transaction context against the provided preimage data.
 * @ignore
 * @param self - The contract instance
 * @param shPreimage - The preimage data containing hash commitments
 * @param inputIndex - Index of the current input
 * @param prevouts - Serialized previous outputs
 * @param prevout - Current output being spent
 * @param spentScriptHashes - Hashes of spent script hashes
 * @param spentAmounts - Hashes of spent amounts
 * @param stateHashes - Hashes of spent data
 * @returns true if all validations pass, otherwise throws assertion errors
 */
export function checkCtxImpl(
  self: AbstractContract,
  shPreimage: SHPreimage,
  inputIndex: InputIndex,
  prevouts: Prevouts,
  prevout: Outpoint,
  spentScriptHashes: SpentScriptHashes,
  spentAmounts: SpentAmounts,
  stateHashes: SpentDataHashes,
): boolean {
  // check sHPreimage
  self.checkSHPreimage(shPreimage);

  // Check if ANYONECANPAY flag is set
  const hasAnyoneCanPay = (shPreimage.sigHashType & SIGHASH_ANYONECANPAY) !== 0n;

  // Extract base sighash type (without ANYONECANPAY)
  const baseSigHashType = shPreimage.sigHashType & SIGHASH_BASE_MASK;

  // Check if SIGHASH_NONE is set
  const isSigHashNone = baseSigHashType === SIGHASH_NONE;

  // check inputIndex
  assert(BigInt(inputIndex) === shPreimage.inputIndex, 'inputIndex mismatch');

  // For ANYONECANPAY, hashPrevouts should be empty (all zeros)
  // Otherwise, validate against the calculated hash
  if (hasAnyoneCanPay) {
    assert(
      shPreimage.hashPrevouts === EMPTY_HASH,
      'hashPrevouts should be empty for ANYONECANPAY',
    );
  } else {
    // check prevouts
    assert(
      tools.compare(
        tools.fromHex(shPreimage.hashPrevouts),
        tools.fromHex(hash256(prevouts)),
      ) === 0,
      'hashPrevouts mismatch',
    );

    // check prevout (only meaningful when not ANYONECANPAY)
    assert(prevout.txHash + intToByteString(prevout.outputIndex, 4n) === slice(prevouts, BigInt(inputIndex)*36n, BigInt(inputIndex + 1)*36n), `invalid prevout`);
  }

  // For ANYONECANPAY, hashSpentScriptHashes, hashSpentAmounts, hashSpentDataHashes should be empty
  if (hasAnyoneCanPay) {
    assert(
      shPreimage.hashSpentScriptHashes === EMPTY_HASH,
      'hashSpentScriptHashes should be empty for ANYONECANPAY',
    );
    assert(
      shPreimage.hashSpentAmounts === EMPTY_HASH,
      'hashSpentAmounts should be empty for ANYONECANPAY',
    );
    assert(
      shPreimage.hashSpentDataHashes === EMPTY_HASH,
      'hashSpentDataHashes should be empty for ANYONECANPAY',
    );
  } else {
    // check spentScripts
    assert(
      tools.compare(
        tools.fromHex(shPreimage.hashSpentScriptHashes),
        tools.fromHex(
          hash256(spentScriptHashes),
        ),
      ) === 0,
      'hashSpentScriptHashes mismatch',
    );

    // check spentAmounts
    assert(
      tools.compare(
        tools.fromHex(shPreimage.hashSpentAmounts),
        tools.fromHex(hash256(spentAmounts)),
      ) === 0,
      'hashSpentAmounts mismatch',
    );

    assert(
      tools.compare(
        tools.fromHex(shPreimage.hashSpentDataHashes),
        tools.fromHex(hash256(stateHashes)),
      ) === 0,
      'hashSpentDataHashes mismatch',
    );
  }

  // For SIGHASH_NONE, hashOutputs should be empty (no outputs are signed)
  if (isSigHashNone) {
    assert(
      shPreimage.hashOutputs === EMPTY_HASH,
      'hashOutputs should be empty for SIGHASH_NONE',
    );
  }

  return true;
}
