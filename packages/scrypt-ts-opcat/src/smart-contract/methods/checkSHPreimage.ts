import { AbstractContract } from '../abstractContract.js';
import { SHPreimage, Sig } from '../types/index.js';
import { ContextUtils } from '../builtin-libs/contextUtils.js';
import { SmartContract } from '../smartContract.js';
import { sha256 } from '../fns/hashes.js';
import { slice, len } from '../fns/byteString.js';
import { encodeSHPreimage } from '../../utils/preimage.js';


/**
 * Verifies a signature against the contract's public key using the provided SH preimage.
 *
 * This function uses a two-step verification process:
 * 1. checkDataSig - verifies the signature against sha256(serialized_preimage)
 *    Since checkDataSig internally applies sha256, it becomes sha256(sha256(preimage)) = hash256(preimage)
 * 2. checkSig - verifies the signature against the actual transaction preimage (hash256)
 *
 * The signature is expected to be pre-generated off-chain over hash256(preimage)
 * and injected via the _injectedPreimageSig property on SmartContract instances.
 *
 * @ignore
 * @param self - The contract instance to verify against
 * @param shPreimage - The SH preimage containing the signature to verify
 * @returns True if the signature is valid for this contract's public key
 */
export function checkSHPreimageImpl(self: AbstractContract, shPreimage: SHPreimage): boolean {
  // Get the injected signature from the SmartContract instance
  const smartContract = self as SmartContract;
  const sig: Sig | undefined = smartContract._injectedPreimageSig;

  if (!sig) {
    throw new Error(
      'Preimage signature not injected. Ensure the method is called with proper context injection.'
    );
  }

  // Use encodeSHPreimage which is the same serialization used in checkSigImpl
  const preimage = encodeSHPreimage(shPreimage);

  // For checkDataSig (OP_CHECKSIGFROMSTACK), we need pure DER signature without sighash type.
  // The injected signature includes sighash type at the end, so we strip it using slice.
  // This uses scrypt-ts slice function which works both in JS runtime and on-chain.
  const pureDerSig = Sig(slice(sig, 0n, len(sig) - 1n));

  // Verify using checkDataSig with sha256(preimage) as message
  // The signature was created over hash256(preimage).reverse()
  // checkDataSig internally applies sha256: sha256(sha256(preimage)) = hash256(preimage)
  // Then reverses to match the signature format
  const dataCheck = self.checkDataSig(pureDerSig, sha256(preimage), ContextUtils.pubKey);

  // Verify using checkSig (signature against transaction preimage which uses hash256)
  // checkSig expects signature with sighash type appended
  const sigCheck = self.checkSig(sig, ContextUtils.pubKey);

  return dataCheck && sigCheck;
}
